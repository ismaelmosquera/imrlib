/*
 * Copyright (c) 2023 Ismael Mosquera Rivera
 *
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

/*
* CScale.java
*
* Author: Ismael Mosquera Rivera
*/

import imr.media.audio.Envelope;
import imr.media.audio.Oscillator;
import imr.media.audio.RawDataPlayer;
import imr.media.audio.RawDataStorage;

import javax.sound.sampled.UnsupportedAudioFileException;

/*
*
* This example demonstrates the following classes:
* - Envelope
* - Oscillator
* - RawDataPlayer
* - RawDataStorage
*
* What the example actually does is to play the C major
* musical scale for the second octave. For this purpose,
* an oscillator is used to generate the frequencies of the musical notes
* in the scale then, applies an envelope to the data generated by the oscillator; after apply
* the envelope, the data is played by a RawDataPlayer object and accumulated
* by a RawDataStorage object to, finally, store the result
* in a wave audio file ( out.wav ).
*
*/
public class C2Scale
{

public C2Scale()
{
	_osc = new Oscillator(0.8f, C2, 22050.0f);
	_env = new Envelope(_osc.getAmplitude(), 20, 20, 50, 10, _osc.getSampleRate(), 0.5f, 500.0f);
	_player = new RawDataPlayer(_osc.getSampleRate());
	_saver = new RawDataStorage(_osc.getSampleRate());
	composeScale();
}

public void play()
{
_player.start();

int bufferSize = (int)_player.getFormat().getSampleRate();
bufferSize -= bufferSize % 4;
byte[] silence = new byte[bufferSize];
for(int k = 0; k < silence.length; k++) silence[k] = (byte)0x00;
byte[] end_frame = new byte[bufferSize*2];
for(int k = 0; k < end_frame.length; k++) end_frame[k] = (byte)0x00;

int i = 0;
byte[] data = new byte[bufferSize];
while(true)
{
_osc.read(data);
_env.apply(data);
_player.play(data);
_saver.add(data);

try
{
Thread.sleep(500);
}
catch(InterruptedException e) {}

if(i > f.length-1) break;
_saver.add(silence);
_osc.setFrequency(f[i]);
i++;
}
_player.stop();
_saver.add(end_frame);

try
{
_saver.store("out.wav");
}
catch(UnsupportedAudioFileException e)
{
	System.out.println(e);
	}
}


private void composeScale()
{
float freq = C2;
f = new float[t.length];
for(int i = 0; i < f.length; i++)
{
for(int j = 0; j < t[i]; j++)
{
	if(i < 7)
	{
		freq *= PITCH_INC_FACTOR;
	}
	else
	{
	freq /= PITCH_INC_FACTOR;
	}
}
f[i] = freq;
}
}


private Oscillator _osc;
private Envelope _env;
private RawDataPlayer _player;
private RawDataStorage _saver;

private float[] f;
private int[] t = {2, 2, 1, 2, 2, 2, 1, 1, 2, 2, 2, 1, 2, 2};
private static final float C2 = 65.4f;
private static final float PITCH_INC_FACTOR = (float)Math.pow(2.0, 1.0 / 12.0);
}

// END
